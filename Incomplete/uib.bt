//------------------------------------------------
//--- 010 Editor v15.0 Binary Template
//
//      File: Final Fantasy XVI UI Binary
//   Authors: Uhhhh, Nenkai
//   Version: 
//   Purpose: 
//  Category: UI
// File Mask: *.uib
//  ID Bytes: 0x55 0x49 0x42
//   History: 
//------------------------------------------------

const uint64 Sky_400<hidden=true> = 0xF8BD38;
const uint64 Sky_500<hidden=true> = 0xE9A50E;
const uint64 Sky_700<hidden=true> = 0xC78402;
const uint64 Sky_800<hidden=true> = 0x855907;
const uint64 Sky_900<hidden=true> = 0x6E4A0C;

const uint64 Teal_400<hidden=true> = 0xA6B814;
const uint64 Teal_500<hidden=true> = 0x88940D;
const uint64 Teal_700<hidden=true> = 0x6E760F;
const uint64 Teal_800<hidden=true> = 0x595E11;
const uint64 Teal_900<hidden=true> = 0x4A4E13;

const uint64 Green_400<hidden=true> = 0x5EC522;
const uint64 Green_500<hidden=true> = 0x5EC522;
const uint64 Green_700<hidden=true> = 0x518D2D;
const uint64 Green_800<hidden=true> = 0x346516;
const uint64 Green_900<hidden=true> = 0x42652C;

const uint64 Amber_400<hidden=true> = 0x24BFFB;
const uint64 Amber_500<hidden=true> = 0x0B9EF5;
const uint64 Amber_600<hidden=true> = 0x0677D9;
const uint64 Amber_700<hidden=true> = 0x0953B4;
const uint64 Amber_800<hidden=true> = 0x0E4092;
const uint64 Amber_900<hidden=true> = 0x0F3578;

const uint64 Red_400<hidden=true> = 0x7171F8;
const uint64 Red_500<hidden=true> = 0x4444EF;
const uint64 Red_600<hidden=true> = 0x2626DC;
const uint64 Red_700<hidden=true> = 0x1C1CB9;
const uint64 Red_800<hidden=true> = 0x1B1B99;
const uint64 Red_900<hidden=true> = 0x1D1D7F;

struct MemberList;
struct BezierNode;

typedef struct(uint numBytes){
    ubyte bytes[numBytes];
} Padding;

typedef struct TColor{
    ubyte r;
    ubyte g;
    ubyte b;
    ubyte a;
    
    local uint full_color<format=hex> = a;
    full_color = full_color << 8;
    full_color |= b;
    full_color = full_color << 8;
    full_color |= g;
    full_color = full_color << 8;
    full_color |= r;
} Color<bgcolor=(this.full_color & 0xFFFFFF)>;

enum BlendMode{
    kNormal,
    kDarken,
    kMultiply,
    kColorBurn,
    kLinearBurn,
    kLighten,
    kScreen,
    kColorDodge,
    kLinearDodge,
    kOverlay,
    kSoftLight,
    kHardLight,
    kVividLight,
    kLinearLight,
    kHdrBlend,
    kHdrLowBlend,
    kHdrHighBlend,
};

enum LayerEffect{
    kColorFilter,
    kChromaticAberration,
    kBlur,
    kDropShadow,
    kGlow,
    kRadialBlur,
    kBackgroundBlur,
    kAlphaMask,
    kImageMask,
    kAntiAliasing,
};

typedef struct TMemberStruct_0{
    int value_0;
    int value_1;
    int value_2;
    int starting_frame<bgcolor=cLtRed>;
    int duration;
    int item_index<fgcolor=cGreen>;
    ubyte bool_0;
    ubyte bool_1;
    short padding<bgcolor=cNone>;
    int data_offset<bgcolor=cDkRed>;
    
    FSeek(startof(value_0) + data_offset);
    
    struct 
    {
        int id_maybe;
        switch(id_maybe)
        {
            // 0x1391: Likely for textures
            // 0x13A3: For beziers

            case 0x13A3: { 
                int stuff[20]<bgcolor=cGray>;
                int offset;
                int count;
                
                FSeek(startof(id_maybe) + offset);
                BezierNode nodes[count];
                break;
            }
            default: {
                
                break;
            }
        }
    } member_data<bgcolor=cDkGreen>;
    
    
    FSeek(startof(data_offset) + 4);
} MemberStruct_0<bgcolor=cRed, name = Str("%Xh: Item %d ", this.value_2, this.item_index)>;

typedef struct TMemberStruct_1(uint count){
    int offsets[count]<bgcolor=Teal_400>;
    
    local int i <hidden=true>;
    for( i = 0 ; i < count ; i++ )
    {
        FSeek( startof(offsets) + offsets[i] );
        struct{
            int value_0;
            if(value_0 == 0xFA2)
            {
                int values[9]<bgcolor=cGray>;
            }
            else
            {
                int values[10]<bgcolor=cGray>;
                FSeek(startof(value_0) + values[9]);
                string name<bgcolor=cNone>;
                FSeek(startof(values[9]) + 4);
            }
            
        } test<name = (exists(this.name) ? this.name : "")>;
    }
} MemberStruct_1<bgcolor=cPurple>;

typedef struct TTimelineMember{
    uint name_offset;
    FSeek(startof(name_offset) + name_offset);
    
    string name<bgcolor=Sky_500>;
    
    FSeek(startof(name_offset) + 4);
    
    uint flags<format=hex>;
    
    struct{
        int type_maybe;
        int offset_0;
        int count_0;
        
        int offset_1;
        int count_1;
        
        int offset_2;
        int count_2;
        
        if (count_0)
        {
            FSeek(startof(type_maybe) + offset_0);
            MemberStruct_0 timeline_elements[count_0]<optimize=false>;
        }
        
        FSeek(startof(type_maybe) + offset_1);
        
        struct{
            int unknown_0;
            int unknown_1;
            int unknown_2;
        } sanity_1[count_1]<bgcolor=cGreen>;
        
        FSeek(startof(type_maybe) + offset_2);
        
        MemberStruct_1 items(count_2);
        struct{
          int unk_0;
          int offset_0;
          int offset_1; 
          
          FSeek(startof(unk_0) + offset_1);
          int unk_1;
          int offset_2;
          
          FSeek(startof(unk_0) + offset_0);
          string str_0;
          
          FSeek(startof(unk_1) + offset_2);
          string str_1;
          
        } member_struct_2<bgcolor=Amber_800>;
        
        FSeek(startof(type_maybe) + 28);
    } unknown_0;
    
    int duration;
    byte data[56]<bgcolor=cGray>;
} TimelineMember<name = this.name>;

typedef struct TTimelineCollection(uint64 startPoint){
    uint collection_offset <format=hex, fgcolor=cRed>;
    uint member_count <fgcolor=cGreen>;
    
    if (member_count)
    {
        FSeek(startPoint + collection_offset);
        TimelineMember members[member_count]<optimize=false>;
    }
    
    FSeek(startof(member_count) + 4);
} TimelineCollection;


enum MemberType{
    kGroup = 0x1,
    kImage = 0x2,
    kUnknown3 = 0x3,
    kUnknown4 = 0x4,
    kUnknown5 = 0x5,
    kRectangle = 0x6,
    kEllipse = 0x7,
    kBezier = 0x8,
    kGroupRef = 0xA,
    kEffect = 0xB,
};

typedef struct TGroup(uint64 startPoint){
    byte unknown[60]<bgcolor=cGray>;
    //MemberList list(startPoint);
} Group;

typedef struct TImage{
    int unknown_1;
    int unknown_2;
    Color color;
} Image;

typedef struct TRectangle{
    int unknown_1;
    int unknown_2;
    Color color;
} Rectangle;

typedef struct TEllipse{
    int unknown_1;
    int unknown_2;
    Color color;
} Ellipse;

typedef struct TBezierNode{
    int x<bgcolor=cBlue>;
    int y<bgcolor=cBlue>;
    int handle_a_x;
    int handle_a_y;
    int handle_b_x;
    int handle_b_y;
    float unknown_floats[8];
} BezierNode<bgcolor=cDkBlue, name = Str("Node(%d, %d) - A(%d, %d), B(%d, %d) ", this.x, this.y, this.handle_a_x, handle_a_y, handle_b_x, handle_b_y)>;

typedef struct TBezier{
    int unknown_1;
    int unknown_2;
    Color color;
    byte unknown_data_1[120]<bgcolor=cGray>;
    
    int point_count;
    BezierNode nodes[point_count];
} Bezier;

typedef struct TGroupRef{
    int unknown_1;
    int unknown_2;
    Color color;
} GroupRef;

typedef struct TMember(uint64 startPoint){
    uint offset<bgcolor=cRed>;
    
    FSeek(startPoint + offset);
    
    MemberType type;
    uint nameOffset<bgcolor=cWhite>;
    
    FSeek(startof(type) + nameOffset);
    string name<bgcolor=cWhite>;
    
    FSeek(startof(nameOffset) + 4);
    
    int x;
    int y;
    float rotation;
    float scale_x, scale_x;
    int anchor_x, anchor_y;
    Padding unknown_data(32);
    int width, height;
    int offset_to_data;
    int unknown_0;
    Padding maybe_reserved(60);
    if(type == kGroup)
        MemberList children(startof(type));
    
    switch(type)
    {
        case kGroup:
        {
            Group group_data(startof(type));
            break;
        }
        case kImage:
        {
            FSeek(startof(type) + offset_to_data);
            Image image_data;
            break;
        }
        case kEllipse:
        {
            FSeek(startof(type) + offset_to_data);
            Ellipse ellipse_data;
            break;
        }
        case kBezier:
        {
            FSeek(startof(type) + offset_to_data);
            Bezier bezier_data;
            break;
        }
        case kRectangle:
        {
            FSeek(startof(type) + offset_to_data);
            Rectangle rectangle_data;
            break;
        }
        case kGroupRef:
        {
            FSeek(startof(type) + offset_to_data);
            GroupRef group_ref_data;
            break;
        }
        default:
            break;
    }
    
    FSeek(startof(offset) + 4);
} Member<name = Str("(%s) %s ", EnumToString(this.type), this.name), bgcolor=cDkRed>;

typedef struct TMemberList(uint64 startPoint){
    uint offset <fgcolor=cRed, format=hex>;
    uint count <fgcolor=cGreen>;
    
    FSeek(startPoint + offset);
    
    local uint64 start = FTell();
    Member members(start)[count]<optimize=false>;
    
    FSeek(startof(count) + 4);
} MemberList;

typedef struct TLayerProperties{
    int type;
    int name_offset_offset<format=hex, fgcolor=cRed>;
    int name_count<fgcolor=cGreen>;
    int unk_subtype;
    BlendMode blend_mode;
    int maybe_flags;
    int unknowns_0[4];
    int field_0x28;
    float field_0x2C;
    float field_0x30;
    float field_0x34;
    float field_0x38;
    float field_0x3C;
    float field_0x40;
    float field_0x44;
    float field_0x48;
    int field_0x4C;
    float field_0x50;
    float field_0x54;
    float field_0x58;
    float field_0x5C;
    short field_0x60;
    byte field_0x62;
    byte field_0x63;
    float field_0x64;
    int field_0x68;
    float field_0x6C;
    float field_0x70;
    float field_0x74;
    float field_0x78;
    float field_0x7C;
    float field_0x80;
    float field_0x84;
    float field_0x88;
    float field_0x8C;
    float field_0x90;
    float field_0x94;
    int offset_0x98 <format=hex, fgcolor=cRed>;
    float field_0x9C;
    float field_0xA0;
    float field_0xA4;
    int name_offset <format=hex, fgcolor=cRed>;
    int name_count <fgcolor=cGreen>;
    int field_0xB0;
    int field_0xB4;
    int field_0xB8;
    float field_0xBC;
    float field_0xC0;
    float field_0xC4;
    float field_0xC8;
    float field_0xCC;
    float field_0xD0;
    float field_0xD4;
    float field_0xD8;
    float field_0xDC;
    float field_0xF0;
    float field_0xF4;
    float field_0xF8;
    float field_0xFC;
    int field_0x100;
    int field_0x104;
    int sub_type_0x108; // Used if type == 1?
    int field_0x10C; // Used if type == 1?
    if (type == 15)
    {
        int field_0x10C;
        int field_0x110;
        float field_0x114;
        float field_0x118;
        float field_0x11C;
        float field_0x120;
        float field_0x124;
        float field_0x128;
        int field_0x12C;
        int field_0x130;
        int field_0x134;
        float field_0x138;
        float field_0x13C;
        float field_0x140;
        float field_0x144;
        float field_0x148;
        float field_0x14C;
        float field_0x150;
        float field_0x154;
        float field_0x158;
        float field_0x15C;
    }
    byte pad[0x28];
    local int endPos = FTell();
        
    struct
    {
        FSeek(startof(type) + name_offset_offset);
        int str_offset[name_count];
    
        FSeek(startof(str_offset) + str_offset[0]);
        string str;
        
        FSeek(startof(str_offset) + (name_count * 4));
    } names <bgcolor=cGray>;
    
    FSeek(startof(type) + offset_0x98);
    struct
    {
        byte unkdata[0x34];
        
        FSeek(startof(unkdata) + 0x34);
    } struct_0x98 <bgcolor=cLtRed>;
    
    FSeek(endPos);
} LayerProperties <bgcolor=cRed>;

typedef struct TGroupEntry{
    uint name_offset <format=hex, fgcolor=cRed>;
    uint width;
    uint height;
    uint layer_properties_offset <format=hex, fgcolor=cRed>;
    MemberList member_list(startof(name_offset));
    TimelineCollection timeline_collection(startof(name_offset));
    Padding padding(0x20);
    
    FSeek(startof(name_offset) + layer_properties_offset);
    LayerProperties layer_properties;
    
    FSeek(startof(name_offset) + name_offset);
    string name<bgcolor=cPurple>;
    
    FSeek(startof(name_offset) + 0x40);
} GroupEntry<name = Str("%s (%dx%d) ", this.name, this.width, this.height)>;

typedef struct TAssetEntry{
    enum {
        kInvalid,
        kTexture,
        kUi,
        kVfx,
    } type_maybe;
    
    int texture_path_offset<format=hex, fgcolor=cRed>;
    int name_info_offset<format=hex, fgcolor=cRed>;
    int pad[8] <hidden=true>;
    
    FSeek(startof(type_maybe) + texture_path_offset);
    string uri<bgcolor=Amber_700>;
    
    FSeek(startof(type_maybe) + name_info_offset);
    struct
    {
        int unknown <format=hex>;
        int part_path_offset <format=hex, fgcolor=cRed>;
        
        FSeek(startof(unknown) + part_path_offset);
        string path<bgcolor=Amber_400>;
        
        FSeek(startof(unknown) + 0x08);
    } name_info <comment=path, bgcolor=cBlue>;

    FSeek(startof(type_maybe) + 0x2C);
} AssetEntry;

typedef struct TAssetCollection{
    int texture_list_offset<format=hex, fgcolor=cRed>;
    int texture_count<fgcolor=cGreen>;
    
    int ui_entries_list_offset<format=hex, fgcolor=cRed>;
    int ui_entry_count<fgcolor=cGreen>;
    
    int vfx_list_offset<format=hex, fgcolor=cRed>;
    int vfx_entry_count<fgcolor=cGreen>;
    int pad[7];
    
    if (texture_count)
    {
        FSeek(startof(texture_list_offset) + texture_list_offset);
        struct
        {
            int offsets[texture_count] <format=hex, fgcolor=cRed, bgcolor=cGray>;
            local int i<hidden=true>;
            for( i = 0 ; i < texture_count ; i++ )
            {
                FSeek(startof(offsets) + offsets[i]);
                AssetEntry texture_entry;
            }
        } textures;
    }
    
    if (ui_entry_count)
    {
        FSeek(startof(texture_list_offset) + ui_entries_list_offset);
        struct
        {
            int offsets[ui_entry_count]<format=hex, fgcolor=cRed>;
            local int i<hidden=true>;
            for( i = 0 ; i < ui_entry_count ; i++ )
            {
                FSeek(startof(offsets) + offsets[i]);
                AssetEntry ui_entry;
            }
        } ui_entries;
    }
    
    if (vfx_entry_count)
    {
        FSeek(startof(texture_list_offset) + vfx_list_offset);
        struct
        {
            int offsets[vfx_entry_count]<format=hex, fgcolor=cRed>;
            local int i<hidden=true>;
            for( i = 0 ; i < vfx_entry_count ; i++ )
            {
                FSeek(startof(offsets) + offsets[i]);
                AssetEntry vfx_entry;
            }
        } ui_entries;
    }
    
    FSeek(startof(texture_list_offset) + 0x34);
} AssetCollection;

typedef struct TUIBHeader{
    uint magic<format=hex, comment="'UIB\\0', checked">;
    uint version<comment="FF16: Version 10 expected">;
    byte reserved[16];
    uint headerSize <format=hex>;
    byte _empty_[16];
} UIBHeader<bgcolor=cPurple>;

UIBHeader header;
FSeek(startof(header) + header.headerSize);

struct{
    int array_list_offset<format=hex, fgcolor=cRed>;
    int group_list_offset<format=hex, fgcolor=cRed>;
    int group_count<fgcolor=cGreen>;
} toc <bgcolor=cRed, size=0x2C>;

FSeek(startof(toc) + toc.array_list_offset);

AssetCollection assets <bgcolor=cYellow>;

FSeek(startof(toc) + toc.group_list_offset);
local int i = 0;

struct
{
    for (i = 0; i < toc.group_count; i++)
    {
        FSeek(startof(toc) + toc.group_list_offset + (i * 0x40));
        GroupEntry layer <bgcolor=cBlue>;
    }
} layers;